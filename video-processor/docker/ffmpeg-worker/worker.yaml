apiVersion: apps/v1
kind: Deployment
metadata:
  name: video-worker
  namespace: video-processor
  labels:
    app: video-processing-system
    component: worker
spec:
  replicas: 2
  selector:
    matchLabels:
      app: video-worker
  template:
    metadata:
      labels:
        app: video-worker
        component: worker
    spec:
      containers:
      - name: worker
        image: alpine:3.18
        imagePullPolicy: IfNotPresent
        command: ["/bin/sh", "-c"]
        args:
        - |
          echo "Installing packages..."
          apk add --no-cache ffmpeg python3 py3-pip py3-requests
          echo "Packages installed successfully"
          
          mkdir -p /app
          echo "App directory created"
          
          cat > /app/worker.py << 'EOF'
          import os
          import time
          import subprocess
          import requests
          from pathlib import Path
          import json
          import signal
          import sys
          
          STORAGE_PATH = "/storage"
          INPUT_PATH = f"{STORAGE_PATH}/input"
          OUTPUT_PATH = f"{STORAGE_PATH}/output"
          API_URL = os.getenv("API_URL", "http://api-service:8080")
          WORKER_ID = os.getenv("HOSTNAME", "worker-unknown")
          
          # Global flag for graceful shutdown
          shutdown_requested = False
          
          def signal_handler(signum, frame):
              global shutdown_requested
              print(f"[{WORKER_ID}] Received shutdown signal {signum}")
              shutdown_requested = True
          
          def ensure_directories():
              """Ensure storage directories exist"""
              try:
                  Path(INPUT_PATH).mkdir(parents=True, exist_ok=True)
                  Path(OUTPUT_PATH).mkdir(parents=True, exist_ok=True)
                  print(f"[{WORKER_ID}] Storage directories ready")
                  return True
              except Exception as e:
                  print(f"[{WORKER_ID}] Failed to create directories: {e}")
                  return False
          
          def create_test_video(input_file, duration=5):
              """Create a test video file for demonstration"""
              try:
                  print(f"[{WORKER_ID}] Creating test video: {input_file}")
                  cmd = [
                      'ffmpeg', '-f', 'lavfi', 
                      '-i', f'testsrc=duration={duration}:size=640x480:rate=30',
                      '-f', 'lavfi', '-i', f'sine=frequency=1000:duration={duration}',
                      '-c:v', 'libx264', '-c:a', 'aac', '-t', str(duration), 
                      '-pix_fmt', 'yuv420p', '-y', input_file
                  ]
                  result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
                  
                  if result.returncode == 0:
                      print(f"[{WORKER_ID}] Test video created successfully")
                      return True
                  else:
                      print(f"[{WORKER_ID}] Failed to create test video: {result.stderr}")
                      return False
                      
              except subprocess.TimeoutExpired:
                  print(f"[{WORKER_ID}] Test video creation timed out")
                  return False
              except Exception as e:
                  print(f"[{WORKER_ID}] Error creating test video: {e}")
                  return False
          
          def process_video(job_data):
              """Process video based on job configuration"""
              input_file = f"{INPUT_PATH}/{job_data['input_filename']}"
              output_file = f"{OUTPUT_PATH}/{job_data['output_filename']}"
              
              # Create test input file if it doesn't exist
              if not os.path.exists(input_file):
                  if not create_test_video(input_file):
                      return False, "Failed to create test input video"
              
              # Verify input file exists and has content
              if not os.path.exists(input_file) or os.path.getsize(input_file) == 0:
                  return False, "Input file is missing or empty"
              
              try:
                  # Build processing command based on operation
                  if job_data['operation'] == 'compress':
                      cmd = [
                          'ffmpeg', '-i', input_file,
                          '-c:v', 'libx264', '-crf', '28',
                          '-c:a', 'aac', '-b:a', '128k',
                          '-preset', 'fast',
                          '-y', output_file
                      ]
                  elif job_data['operation'] == 'resize':
                      resolution = job_data.get('resolution', '720x480')
                      cmd = [
                          'ffmpeg', '-i', input_file,
                          '-vf', f'scale={resolution}',
                          '-c:a', 'copy',
                          '-y', output_file
                      ]
                  elif job_data['operation'] == 'thumbnail':
                      cmd = [
                          'ffmpeg', '-i', input_file,
                          '-vf', 'thumbnail,scale=320:240',
                          '-frames:v', '1',
                          '-y', output_file
                      ]
                  else:
                      return False, f"Unknown operation: {job_data['operation']}"
                  
                  print(f"[{WORKER_ID}] Processing with command: {' '.join(cmd[:6])}...")
                  
                  # Execute FFmpeg command with timeout
                  result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
                  
                  if result.returncode == 0:
                      # Verify output file was created
                      if os.path.exists(output_file) and os.path.getsize(output_file) > 0:
                          file_size = os.path.getsize(output_file)
                          return True, f"Processing completed successfully. Output size: {file_size} bytes"
                      else:
                          return False, "Output file was not created or is empty"
                  else:
                      error_msg = result.stderr.strip() if result.stderr else "Unknown FFmpeg error"
                      print(f"[{WORKER_ID}] FFmpeg error: {error_msg}")
                      return False, f"FFmpeg processing failed: {error_msg}"
                      
              except subprocess.TimeoutExpired:
                  print(f"[{WORKER_ID}] Processing timed out")
                  return False, "Processing timed out after 2 minutes"
              except Exception as e:
                  print(f"[{WORKER_ID}] Unexpected error during processing: {e}")
                  return False, f"Unexpected error: {str(e)}"
          
          def update_job_status(job_id, status, message=""):
              """Update job status via API"""
              try:
                  response = requests.post(
                      f"{API_URL}/jobs/{job_id}/status", 
                      json={"status": status, "message": message},
                      timeout=10
                  )
                  response.raise_for_status()
                  print(f"[{WORKER_ID}] Updated job {job_id[:8]}... status: {status}")
                  return True
              except requests.exceptions.Timeout:
                  print(f"[{WORKER_ID}] Timeout updating job status for {job_id[:8]}...")
                  return False
              except requests.exceptions.RequestException as e:
                  print(f"[{WORKER_ID}] Failed to update job status: {e}")
                  return False
              except Exception as e:
                  print(f"[{WORKER_ID}] Unexpected error updating job status: {e}")
                  return False
          
          def wait_for_api():
              """Wait for API to become available"""
              max_retries = 30
              retry_count = 0
              
              while retry_count < max_retries and not shutdown_requested:
                  try:
                      response = requests.get(f"{API_URL}/health", timeout=5)
                      if response.status_code == 200:
                          print(f"[{WORKER_ID}] API is ready")
                          return True
                  except:
                      pass
                  
                  retry_count += 1
                  print(f"[{WORKER_ID}] Waiting for API... ({retry_count}/{max_retries})")
                  time.sleep(2)
              
              return False
          
          def main():
              """Main worker loop"""
              # Set up signal handlers
              signal.signal(signal.SIGTERM, signal_handler)
              signal.signal(signal.SIGINT, signal_handler)
              
              print(f"[{WORKER_ID}] FFmpeg Worker starting...")
              
              # Ensure storage directories exist
              if not ensure_directories():
                  print(f"[{WORKER_ID}] Failed to set up storage directories")
                  sys.exit(1)
              
              # Wait for API to be ready
              if not wait_for_api():
                  print(f"[{WORKER_ID}] API not available, exiting")
                  sys.exit(1)
              
              consecutive_errors = 0
              max_consecutive_errors = 5
              jobs_processed = 0
              
              print(f"[{WORKER_ID}] Ready to process jobs")
              
              while not shutdown_requested:
                  try:
                      # Poll for new jobs
                      response = requests.get(f"{API_URL}/jobs/next", timeout=10)
                      
                      if response.status_code == 200:
                          job = response.json()
                          job_id = job['id']
                          
                          print(f"[{WORKER_ID}] Processing job {job_id[:8]}... (job number {jobs_processed + 1})")
                          
                          # Update job status to processing
                          if not update_job_status(job_id, "processing", f"Processing on {WORKER_ID}"):
                              print(f"[{WORKER_ID}] Failed to update job status, but continuing...")
                          
                          # Process the video
                          success, message = process_video(job)
                          
                          if success:
                              update_job_status(job_id, "completed", message)
                              print(f"[{WORKER_ID}] Job {job_id[:8]}... completed successfully")
                              jobs_processed += 1
                          else:
                              update_job_status(job_id, "failed", message)
                              print(f"[{WORKER_ID}] Job {job_id[:8]}... failed: {message}")
                          
                          consecutive_errors = 0  # Reset error counter on successful job fetch
                      
                      elif response.status_code == 404:
                          # No jobs available - this is normal
                          if consecutive_errors == 0:  # Only log first time
                              print(f"[{WORKER_ID}] No jobs available, waiting...")
                          consecutive_errors = 0
                      else:
                          consecutive_errors += 1
                          print(f"[{WORKER_ID}] Unexpected API response: {response.status_code}")
                      
                      # Sleep between polls
                      time.sleep(3)
                      
                  except requests.exceptions.Timeout:
                      consecutive_errors += 1
                      print(f"[{WORKER_ID}] API request timeout ({consecutive_errors}/{max_consecutive_errors})")
                      
                  except requests.exceptions.ConnectionError:
                      consecutive_errors += 1
                      print(f"[{WORKER_ID}] API connection error ({consecutive_errors}/{max_consecutive_errors})")
                      
                  except requests.exceptions.RequestException as e:
                      consecutive_errors += 1
                      print(f"[{WORKER_ID}] API request error ({consecutive_errors}/{max_consecutive_errors}): {e}")
                      
                  except Exception as e:
                      consecutive_errors += 1
                      print(f"[{WORKER_ID}] Unexpected error ({consecutive_errors}/{max_consecutive_errors}): {e}")
                  
                  # Handle too many consecutive errors
                  if consecutive_errors >= max_consecutive_errors:
                      print(f"[{WORKER_ID}] Too many consecutive errors, restarting in 30 seconds...")
                      time.sleep(30)
                      consecutive_errors = 0
                      
                      # Try to reconnect to API
                      if not wait_for_api():
                          print(f"[{WORKER_ID}] Could not reconnect to API, exiting")
                          break
                  elif consecutive_errors > 0:
                      # Exponential backoff for errors
                      sleep_time = min(2 ** consecutive_errors, 30)
                      print(f"[{WORKER_ID}] Backing off for {sleep_time} seconds...")
                      time.sleep(sleep_time)
              
              print(f"[{WORKER_ID}] Worker shutting down gracefully. Processed {jobs_processed} jobs.")
          
          if __name__ == "__main__":
              main()
          EOF
          
          echo "Worker script created successfully"
          echo "Starting Python worker..."
          python3 /app/worker.py
        env:
        - name: API_URL
          value: "http://api-service:8080"
        - name: WORKER_POLL_INTERVAL
          value: "3"
        volumeMounts:
        - name: video-storage
          mountPath: /storage
        livenessProbe:
          exec:
            command:
            - /bin/sh
            - -c
            - "ps aux | grep '[p]ython3 /app/worker.py' || exit 1"
          initialDelaySeconds: 60
          periodSeconds: 30
          timeoutSeconds: 10
          failureThreshold: 3
        readinessProbe:
          exec:
            command:
            - /bin/sh
            - -c
            - "test -d /storage/input && test -d /storage/output || (mkdir -p /storage/input /storage/output && echo 'ready')"
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
      volumes:
      - name: video-storage
        persistentVolumeClaim:
          claimName: video-storage-pvc
      restartPolicy: Always
